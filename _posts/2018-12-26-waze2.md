---
title: Waze data for urban interventions - Part II
header:
  teaser: "assets/img/wrangling.png"
excerpt: Data wrangling and the analysis.
classes: wide
---

This is the Part III of a series of three posts. Check out [Part I](/waze1) and [Part II](/waze2) if you haven't done so yet.

## Data Wrangling

Waze provides the data as a JSON file with dozens of *jam* objects. As described in [Part I](/waze1), each one of these objects contains information on the speed, length and other features of that particular jam line.

The problem, however, is that this is not how Municipalities manage their traffic system. It doesn't help us to know that an individual jam line is in *Street X*, if this street is 10km long. The traffic problem could be anywhere on this street and the information no longer helps the traffic engineering team. And yes, Waze does provide the exact coordinates of the jam line, but we need to find a meaningful way of summarizing this data to generate a standardized calculation unit that can allow us to build more sophisticated models.

In Joinville, in particular, our Geographical Information System divide the street network into *street sections* , which are subsections of streets that sit **between two subsequent corners** (see illustration in Figure 1). Our problem, then, is: how can we normalize Waze's traffic information to this standardized traffic network unit?

<img src="/assets/img/waze_to_munic.png">
<figcaption>Figure 1: Standardization of geographical location of jam lines.</figcaption>

## Enter Shapely and Geopandas

Before we tackle how we solved the problem, let's digress a little to explain some basic concepts of GIS programming. In a nutshell, GIS is a way of representing maps through a complex combination of geometric objects containing extra information (attributes):

<img src="/assets/img/gis.png">
<figcaption>Figure 2: GIS in a nutshell.</figcaption>

What we want to do here is to convert Waze's jam lines into a GIS representation, i.e. geometries that can be manipulated with operations such as *intersects*, *contains*, *is contained*, *touches* and etc..

In Python, we use the [shapely](https://shapely.readthedocs.io/en/stable/manual.html) library to achieve that. Furthermore, we want to tabulate the data so each jam line has its own row in a tidy dataframe - the [Pandas](https://pandas.pydata.org/) library is here to help us on that. Finally, we wanna be able to perform Pandas' dataframe JOIN operations using geometrical relations instead of exact matches, such as matching every row in one table whose geometry **intersects** with a row from another table. Or matching every row in one table whose geometry is **entirely contained** by the geometry of another table's row. You get the idea.

<img src="/assets/img/gis_stack.png">
<figcaption>Figure 3: Python stack for GIS handling.</figcaption>

So there it is! With this stack we're finally able to accomplish what we wanted in the first place: cross-reference Waze's data with the Municipality's standard street grid. When this is accomplished, it doesn't take much more than a GROUP BY operation for us to summarize the data and come up with a ranking of the most critical streets:

<img src="/assets/img/waze_join_munic.png">
<figcaption>Figure 4: Ranking of streets after summarizing data.</figcaption>
